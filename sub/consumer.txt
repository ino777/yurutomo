import json
import uuid
import datetime
import asyncio
from django.utils import timezone
from django.core.exceptions import ObjectDoesNotExist
from django.contrib.auth import get_user_model
from django.dispatch import receiver
from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer


from .models import Room, RoomCondition

# from asgiref.sync import async_to_sync  # async_to_sync() : 非同期関数を同期的に実行する際に使用する


User = get_user_model()

USERNAME_SYSTEM = '*system*'


class MatchingConsumer(AsyncWebsocketConsumer):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.user_id = ''
        self.group_id = ''

        # マッチングタスク
        self.task = None

    # WebSocket接続時
    async def connect(self):
        self.user_id = self.scope['user'].pk
        await self.accept()

    # WebSocket切断時
    async def disconnect(self, close_code):
        if self.task is not None and not self.task.cancelled():
            self.task.cancel()
        await self.matching_unregister()

    # WebSocketからデータ受信時
    async def receive(self, text_data=None, bytes_data=None):
        text_data_json = json.loads(text_data)

        if text_data_json.get('data_type') == 'start_wait':
            print(f'Got message from {self.user_id}. "start_wait"')

            # 既に待ち状態の場合はメッセージを返して終了
            if self.task is not None and not self.task.done():
                await self.send(text_data=json.dumps({'message': 'now waiting...'}))
                return
            
            condition = {
                'game_name': 'Test Game',
                'number': 2,
            }
            submission_time = timezone.now()

            loop = asyncio.get_event_loop()
            self.task = loop.create_task(self.matching_task(condition, submission_time))


        elif text_data_json.get('data_type') == 'quit_wait':
            print(f'Got message from {self.user_id}. "quit_wait"')

            # 待ち状態でない場合はメッセージを返して終了
            if self.task is None or self.task.done():
                await self.send(text_data=json.dumps({'message': 'not waiting.'}))
                return

            if self.task is not None and not self.task.cancelled():
                self.task.cancel()
                await self.send_info('cancel matching')

            # マッチングの登録解除
            is_registered = await self.matching_unregister()
            if not is_registered:
                await self.send_info('fail to unregister.')
                return
            
            await self.send_info('unregistered!')

            

    # グループに参加
    async def join_group(self, group_id):
        self.group_id = group_id

        await self.channel_layer.group_add(self.group_id, self.channel_name)

    # グループを離脱
    async def leave_group(self):
        await self.channel_layer.group_discard(self.group_id, self.channel_name)
        self.group_id = ''
    
    # タイムスタンプ付きメッセージ送信
    async def send_info(self, message, **kwargs):
        data = {
            'message': message,
            'datetime': '{:%d-%m-%Y:%H:%M:%S}.{:06d}'.format(timezone.localtime(timezone.now()), timezone.now().microsecond),
        }

        for k, v in kwargs.items():
            kwargs[k] = str(v)
        data.update(kwargs)
        await self.send(text_data=json.dumps(data))

    # 拡散メッセージ
    async def all_message(self, data):
        data_json = {
            'room_id': data['room_id'],
            'message': data['message'],
        }
        await self.send(text_data=json.dumps(data_json))
    
    # マッチングタスク
    async def matching_task(self, condition, submission_time):

        # マッチングに登録
        is_registered = await self.matching_register(condition, submission_time)

        if not is_registered:
            await self.send_info('fail to register.')
            return
        
        await self.send_info('registered!')

        # マッチング待ち
        try:
            room_id = await self.wait_matching_until_complete(condition)
        except ObjectDoesNotExist as ex:
            # objectがないとき

            # マッチング解除
            await self.matching_unregister()
            await self.send_info('error.', error=ex)
            return


        # マッチング完了後は登録解除
        await self.matching_unregister()

        # グループに参加
        await self.join_group(str(room_id))

        # roomIDを送信
        await self.send_info('got matched!', room_id=room_id)

    # マッチングに登録
    @database_sync_to_async
    def matching_register(self, condition, submission_time):
        defaults = dict(
            user=User.objects.get(pk=self.user_id),
            game_name=condition['game_name'],
            number=condition['number'],
            submission_time=submission_time,
            is_active=True
        )

        room_condition, created = RoomCondition.objects.update_or_create(
            user=User.objects.get(pk=self.user_id),
            defaults=defaults,
        )
        room_condition.save()

        return True

    # マッチングを登録解除
    @database_sync_to_async
    def matching_unregister(self):
        
        room_condition = RoomCondition.objects.filter(user=self.user_id, is_active=True).first()
        if room_condition is None:
            return False
        # is_active を False にする
        room_condition.is_active = False
        room_condition.save()
        return True

    # 終わるまでマッチングを待つ
    async def wait_matching_until_complete(self, condition):
        room_id = None

        # マッチングをしてみる
        try:
            room_id = await self.matching(condition)
        except ObjectDoesNotExist:
            raise
        
        # マッチングが完了すればルームIDを返す
        if room_id:
            return room_id

        # 1回でマッチングできなかった場合、マッチングが完了するまでループで待つ
        while True:
            try:
                room_id = await self.matching(condition)
            except ObjectDoesNotExist:
                raise
            if room_id:
                break
            await asyncio.sleep(1)

        return room_id

    # マッチング処理
    @database_sync_to_async
    def matching(self, condition):
        my_room_condition = RoomCondition.objects.filter(user=self.user_id, is_active=True).first()
        # 有効な自分の RoomCondition がなければエラー
        if my_room_condition is None:
            raise ObjectDoesNotExist('Valid room condition does not exist.')

        # condition に合致する RoomCondition のクエリセットを取得
        match_room_conditions = RoomCondition.objects.filter(
            game_name=condition['game_name'], number=condition['number'], is_active=True).order_by('submission_time')

        # クエリセットが条件の数より少ない場合は不適
        if match_room_conditions.count() < condition['number']:
            return

        # クエリセットを条件の数に制限
        match_room_conditions = match_room_conditions[:condition['number']]

        # クエリセットと関連した User を取得し、リスト match_users に格納
        match_users = []
        for room_condition in match_room_conditions:
            match_users.append(room_condition.user)

        # 自分が入っていない場合は不適
        me = User.objects.get(pk=self.user_id)
        if not me in match_users:
            return
        
        if me.pk == match_users[0].pk:
            # submission_time の最も早い人がRoomを作る
            print(self.user_id, 1)
            room = Room.objects.create(is_active=True)
            for user in match_users:
                room.users.add(user)
        else:
            # それ以外の人はRoomを探す
            print(self.user_id, 2)
            room = me.room_set.filter(is_active=True, created_date__gte=my_room_condition.submission_time).order_by('-created_date').first()
        
        # Roomがなければエラー
        if room is None:
            raise ObjectDoesNotExist('Room does not exist.')
        
        return room.pk


